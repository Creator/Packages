 -- class 1.0.1 by Benedict Allen
 --[[ The MIT License (MIT)

Copyright (c) 2015 Benedict Allen

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
 ]]
local e="class" local t=setmetatable({},{__index=getfenv()})t._G=t local a={} local function o(i) if a[i]then local n,s=loadstring(a[i],"["..e.."] "..i..".lua")if not n then error(s,0)end local h=setmetatable({},{__index=t}) setfenv(n,h)local r,d=pcall(n)if not r then error(d,0)end if d==nil then d={} for l,u in pairs(h)do d[l]=u end end t[i]=d return d else return error"file not found"end end a.main="local e,t,a,o,i,n,s=error,tostring,assert,type,setmetatable,getmetatable,pcall local h={} function h.new(r) local d={}local l={}d.public={}d.private={}d.static={}d.name=r d.extends=false d.class=l l.name=r local u=false local c=false local m={} function l:new(...)local w={}local y={}w.class=l w.public=y i(w,{__index=d.private})function y:type(b)return w.class:type(b)end function y:typeOf(h)return w.class:typeOf(h)end local p={} function p.__index(b,g) if d.public[g]then if d.public[g].read then local k if u then if o(u)==\"function\"then return u(w,g)else return u[g]end elseif o(d.public[g].read)==\"function\"then k=d.public[g].read(w)elseif d.public[g].value~=nil then k=d.public[g].value else k=w[g]end if o(k)==\"function\"then return function(q,...)if q==y then return k(w,...)end return k(q,...)end end return k else e(\"variable has no read access\",2)end elseif u then if o(u)==\"function\"then return u(w,g)else return u[g]end else e(\"no such variable \\\"\".. t(g)..\"\\\"\",2)end end function p.__newindex(b,g,k) if d.public[g]then if d.public[g].write then if c then if o(c)==\"function\"then return c(w,g,k)else c[g]=k end elseif o(d.public[g].write)==\"function\"then d.public[g].write(w,k)else w[g]=k end else e(\"variable has no write access\",2)end else e(\"no such variable \\\"\"..t(g)..\"\\\"\",2)end end function p.__tostring()return d.name end p.__metatable={SwiftClassObject=true,__type=d.name}for b,g in pairs(m)do p[\"__\"..t(b)]=g end i(y,p)local v=d while true do if o(v.private[v.name])==\"function\"then return v.private[v.name](w,...)end if v.extends then v=v.extends else break end end return y end function l:type(w)local y=\"\"if w then local p=d.extends while p do y=p.name..\".\"..y p=p.extends end end return y..d.name end function l:typeOf(w) if o(w)==\"table\"then if s(function()a(n(w).SwiftClass)end,\"err\")then local y=d while y do if y.class==w then return true end y=y.extends end end end return false end function l:extends(w)w:extend(d)end function l:extend(w) i(w.static,{__index=d.static})i(w.public,{__index=d.public}) i(w.private,{__index=d.private})w.extends=d end local f={} f.__index=function(w,y) if y==\"static\"then return i({},{__newindex=function(w,y,p)d.static[y]=p end,__metatable={}})elseif y==\"public\"then return i({},{__newindex=function(w,y,p) d.public[y]={read=true,write=false,value=p}end,__call=function(w,y) d.public[y]={read=true,write=true,value=nil} return function(p)local v={p} d.public[y].write=function(g,k) for q=1,#v do if h.typeOf(k,v[q])then g[y]=k return end end if h.type(v[1])==\"Class\"then e(\"expected <\"..v[1]:type()..\"> \"..y,3)else e(\"expected <\"..t(v[1])..\"> \"..y,3)end end local function b(p)table.insert(v,p)return b end return b end end,__index=function(w,y) if d.public[y]then return i({},{__newindex=function(w,r,p) if r==\"read\"then if o(p)==\"boolean\"or o(p)==\"function\"then d.public[y].read=p else e(\"invalid modifier value\",2)end elseif r==\"write\"then if o(p)==\"boolean\"or o(p)==\"function\"then d.public[y].write=p else e(\"invalid modifier value\",2)end else e(\"invalid modifier name\",2)end end,__metatable={}})else e(\"public index \"..t(y)..\" not found\",2)end end,__metatable={}})elseif y==\"meta\"then return i({},{__index=function(w,y) if y==\"index\"then return u elseif y==\"newindex\"then return c else return m[y]end end,__newindex=function(w,y,p) if y==\"metatable\"then e(\"cannot change this metamethod\",2)elseif y==\"index\"then if o(p)==\"function\"or o(p)==\"table\"or p==nil then u=p else e(\"cannot use type \"..o(p)..\" for index metamethod\",2)end elseif y==\"newindex\"then if o(p)== \"function\"or o(p)==\"table\"or p==nil then c=p else e( \"cannot use type \"..o(p)..\" for newindex metamethod\",2)end else m[y]=p end end,__metatable={}})else return d.static[y]end end function f.__newindex(w,y,p)d.private[y]=p end function f.__call(w,...)return w:new(...)end function f.__tostring()return\"Class\"end f.__metatable={SwiftClass=true,__type=\"Class\"}i(l,f)return l end function h.public(r)local d=h.new(r)getfenv(2)[r]=d end function h.type(r) if o(r)==\"table\"then if s(function()a(n(r).SwiftClass)end,\"err\")then return\"Class\"end if s(function() a(n(r).SwiftClassObject)end,\"err\")then return r:type()end end return o(r)end function h.typeOf(r,...)local d={...} for l=1,#d do if o(r)==\"table\"and s(function()a(n(r).SwiftClassObject)end,\"err\")then if r:typeOf(d[l])then return d[l]end elseif o(r)==\"table\"and s(function()a(n(r).SwiftClass)end,\"err\")then if d[l]==\"Class\"then return\"Class\"end else if o(r)== d[l]then return d[l]end end end return false end i(h,{__call=function(r,...)return h.new(...)end})return h"return o"main"