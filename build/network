 -- network 1.0.2 by Benedict Allen
 --[[ The MIT License (MIT)

Copyright (c) 2015 Benedict Allen

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

Handshake:
Used with permission from 1lann
Compressed using Lua Minifier (https://mothereff.in/lua-minifier) ]]
local e="network" local t=setmetatable({},{__index=getfenv()})t._G=t local a={} local function o(i) if a[i]then local n,s=loadstring(a[i],"["..e.."] "..i..".lua")if not n then error(s,0)end local h=setmetatable({},{__index=t}) setfenv(n,h)local r,d=pcall(n)if not r then error(d,0)end if d==nil then d={} for l,u in pairs(h)do d[l]=u end end t[i]=d return d else return error"file not found"end end a.main="local e=math local t={}t.prime=625210769 t.base=-1 t.secret=-1 t.sharedSecret=-1 function t.exponentWithModulo(l,u,m) local c=l for f=1,u-1 do c=c*c if c>=m then c=c%m end end return c end function t.clear()t.base=-1 t.secret=-1 t.sharedSecret=-1 end function t.generateInitiatorData() t.base=e.random(10,99999)t.secret=e.random(10,99999)return {type=\"initiate\",prime=t.prime,base=t.base,moddedSecret=t.exponentWithModulo(t.base,t.secret,t.prime)}end function t.generateResponseData(l)local u=type(l.prime)==\"number\" local c=l.prime==t.prime local m=type(l.base)==\"number\"local f=l.type==\"initiate\"local w= type(l.moddedSecret)==\"number\"local y=u and m and w if y and c then if f then t.base=l.base t.secret=e.random(10,99999) t.sharedSecret=t.exponentWithModulo(l.moddedSecret,t.secret,t.prime)return {type=\"response\",prime=t.prime,base=t.base,moddedSecret=t.exponentWithModulo(t.base,t.secret,t.prime)},t.sharedSecret elseif l.type== \"response\"and t.base>0 and t.secret>0 then t.sharedSecret=t.exponentWithModulo(l.moddedSecret,t.secret,t.prime)return t.sharedSecret else return false end else return false end end local a={}local o={}local i={}local n=false local s={} local function h(l)local u=\"\"e.randomseed(l)for c=1,32 do u=u.. string.char(e.random(0,255))end return u end local r,d function updateModem()if d and peripheral.getType(d)==\"modem\"then return true end for l,u in pairs(peripheral.getNames())do if peripheral.getType(u)==\"modem\"then r=peripheral.wrap(u)d=u r.open(2514) return true end end return false end function forward(l,u)a[l]=a[l]or{}a[l][#a[l]+1]=u end function unforward(l,u)if a[l]then for c=#a[l],1,-1 do if a[l][c]==u then table.remove(a[l],c)end end end end function block(l)o[l]=true end function allow(l)o[l]=false end function whitelist(l) whitelist[l]=true end function unwhitelist(l)whitelist[l]=nil end function send(l,u,c,m)if m and not s[m]then return false,\"no such key\"end if l==os.getComputerID()then os.queueEvent(\"nova_network_message\",l,u,c)return true end updateModem() if r then if m then u=Encryption.encrypt(textutils.serialize(u),s[m])end r.transmit(2514,2514,{isNovaNetworkMessage=true,sender=os.getComputerID(),target=l,data=u,keyindex=m,protocol=c or\"NONE\"})return true end return false,\"no modem found\"end function receive(l,u,c)local m if u then m=os.startTimer(u)end while true do local f,w,y,p,v=coroutine.yield()if f==\"timer\"and w==m then return false end if f==\"nova_network_message\"and( w==l or not l)and(p==c or not c)then return w,y,p,v end end end function response(l,u,c,m,f)local w,y=send(l,u,c,m)if not w then return false,y end return receive(l,f)end function establishKey(l,u)if l==os.getComputerID()then local f,w=e.random(0,32767),e.random(0,32767)s[f]=h(w)return f end while n do coroutine.yield()end n=true send(l,{request=\"KeyEstablish\",data=t.generateInitiatorData(),keyIndex=t.generateInitiatorData()},\"KeyExchange\")local c,m=receive(l,u or 1,\"KeyExchange\")if type(m)==\"table\"then local f=t.generateResponseData(m.data)local w=t.generateResponseData(m.keyIndex)n=false s[w]=h(f) return w end n=false return false end function event(...)local l={...}local u,c,m,f if l[1]==\"modem_message\"then if type(l[5])==\"table\"and l[5].isNovaNetworkMessage and l[5].target==os.getComputerID()then c=l[5].sender u=l[5].data m=l[5].protocol if l[5].keyindex then if s[l[5].keyindex]then u=textutils.unserialize(Encryption.decrypt(u,s[l[5].keyindex]))f=l[5].keyindex else c=nil end end if m== \"KeyExchange\"and type(u)==\"table\"and u.request==\"KeyEstablish\"then local w,y=t.generateResponseData(u.data) local p,v=t.generateResponseData(u.keyIndex)send(c,{data=w,keyIndex=p},\"KeyExchange\")s[v]=h(y) c=nil end end if a[l[2]]then for w,y in pairs(a[l[2]])do if peripheral.getType(y)==\"modem\"then local v=peripheral.wrap(y)v.transmit(l[3],l[4],y)end end end elseif l[1]==\"rednet_message\"then c=l[2]u=l[3]m=l[4]end if c then if not o[c]and(not next(i)or i[c])then os.queueEvent(\"nova_network_message\",c,u,m,f)end end end"return o"main"