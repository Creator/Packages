 -- tween 2.0.0 by Enrique García Cota
 --[[     MIT LICENSE
    Copyright (c) 2014 Enrique García Cota, Yuichi Tateno, Emmanuel Oga
    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:
    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   ]]
local e="tween" local t=setmetatable({},{__index=getfenv()})t._G=t local a={} local function o(i) if a[i]then local n,s=loadstring(a[i],"["..e.."] "..i..".lua")if not n then error(s,0)end local h=setmetatable({},{__index=t}) setfenv(n,h)local r,d=pcall(n)if not r then error(d,0)end if d==nil then d={} for l,u in pairs(h)do d[l]=u end end t[i]=d return d else return error"file not found"end end a.main=" local e={_VERSION='tween 2.0.0',_DESCRIPTION='tweening for lua',_URL='https://github.com/kikito/tween.lua',_LICENSE=\"\"}local t,a,o,i=math,assert,tostring,type local n,s,h,r,d,l,u=t.pow,t.sin,t.cos,t.pi,t.sqrt,t.abs,t.asin local function c(er,ed,el,eu)return el*er/eu+ed end local function m(er,ed,el,eu)return el*n(er/eu,2)+ed end local function f(er,ed,el,eu)er=er/eu return -el*er* (er-2)+ed end local function w(er,ed,el,eu)er=er/eu*2 if er<1 then return el/2*n(er,2)+ed end return-el/2* ((er-1)* (er-3)-1)+ed end local function y(er,ed,el,eu)if er<eu/2 then return f(er*2,ed,el/2,eu)end return m((er*2)-eu,ed+ el/2,el/2,eu)end local function p(er,ed,el,eu)return el*n(er/eu,3)+ed end local function v(er,ed,el,eu)return el* ( n(er/eu-1,3)+1)+ed end local function b(er,ed,el,eu)er=er/eu*2 if er<1 then return el/2*er*er*er+ed end er=er-2 return el/2* (er*er*er+2)+ed end local function g(er,ed,el,eu)if er<eu/2 then return v(er*2,ed,el/2,eu)end return p((er*2)-eu,ed+ el/2,el/2,eu)end local function k(er,ed,el,eu)return el*n(er/eu,4)+ed end local function q(er,ed,el,eu)return-el* ( n(er/eu-1,4)-1)+ed end local function j(er,ed,el,eu)er=er/eu*2 if er<1 then return el/2*n(er,4)+ed end return -el/2* (n(er-2,4)-2)+ed end local function x(er,ed,el,eu)if er<eu/2 then return q(er*2,ed,el/2,eu)end return k((er*2)-eu,ed+ el/2,el/2,eu)end local function z(er,ed,el,eu)return el*n(er/eu,5)+ed end local function _(er,ed,el,eu)return el* ( n(er/eu-1,5)+1)+ed end local function E(er,ed,el,eu)er=er/eu*2 if er<1 then return el/2*n(er,5)+ed end return el/2* (n(er-2,5)+2)+ed end local function T(er,ed,el,eu)if er<eu/2 then return _(er*2,ed,el/2,eu)end return z((er*2)-eu,ed+ el/2,el/2,eu)end local function A(er,ed,el,eu) return-el*h(er/eu* (r/2))+el+ed end local function O(er,ed,el,eu)return el*s(er/eu* (r/2))+ed end local function I(er,ed,el,eu)return-el/2* (h(r*er/eu)-1)+ed end local function N(er,ed,el,eu)if er<eu/2 then return O(er*2,ed,el/2,eu)end return A((er*2)-eu,ed+el/2,el/2,eu)end local function S(er,ed,el,eu)if er==0 then return ed end return el*n(2,10* (er/eu-1))+ed-el* 0.001 end local function H(er,ed,el,eu)if er==eu then return ed+el end return el*1.001* (-n(2,-10*er/eu)+1)+ed end local function R(er,ed,el,eu)if er==0 then return ed end if er==eu then return ed+el end er=er/eu*2 if er<1 then return el/2*n(2,10* (er-1))+ed-el*0.0005 end return el/2*1.0005* (-n(2,-10* (er-1))+2)+ed end local function D(er,ed,el,eu)if er<eu/2 then return H(er*2,ed,el/2,eu)end return S((er*2)-eu,ed+ el/2,el/2,eu)end local function L(er,ed,el,eu)return (-el* (d(1-n(er/eu,2))-1)+ed)end local function U(er,ed,el,eu)return(el* d(1-n(er/eu-1,2))+ed)end local function C(er,ed,el,eu)er=er/eu*2 if er<1 then return-el/2* (d(1-er*er)-1)+ed end er=er-2 return el/2* (d(1-er*er)+1)+ed end local function M(er,ed,el,eu)if er<eu/2 then return U(er*2,ed,el/2,eu)end return L((er*2)-eu,ed+ el/2,el/2,eu)end local function F(er,ed,el,eu)er,ed=er or eu*0.3,ed or 0 if ed<l(el)then return er,el,er/4 end return er, ed,er/ (2*r)*u(el/ed)end local function W(er,ed,el,eu,ec,em)local ef if er==0 then return ed end er=er/eu if er==1 then return ed+el end em,ec,ef=F(em,ec,el,eu)er=er-1 return - (ec*n(2,10*er)* s((er*eu-ef)* (2*r)/em))+ed end local function Y(er,ed,el,eu,ec,em)local ef if er==0 then return ed end er=er/eu if er==1 then return ed+el end em,ec,ef=F(em,ec,el,eu)return ec*n(2,-10*er)*s((er*eu-ef)* (2*r)/em)+el+ed end local function P(er,ed,el,eu,ec,em)local ef if er==0 then return ed end er=er/eu*2 if er==2 then return ed+el end em,ec,ef=F(em,ec,el,eu)er=er-1 if er<0 then return -0.5* (ec*n(2,10*er)* s((er*eu-ef)* (2*r)/em))+ed end return ec* n(2,-10*er)*s((er*eu-ef)* (2*r)/em)*0.5+el+ed end local function V(er,ed,el,eu,ec,em)if er<eu/2 then return Y(er*2,ed,el/2,eu,ec,em)end return W( (er*2)-eu,ed+el/2,el/2,eu,ec,em)end local function B(er,ed,el,eu,ec)ec=ec or 1.70158 er=er/eu return el*er*er* ((ec+1)*er-ec)+ed end local function G(er,ed,el,eu,ec)ec=ec or 1.70158 er=er/eu-1 return el* ( er*er* ((ec+1)*er+ec)+1)+ed end local function K(er,ed,el,eu,ec) ec=(ec or 1.70158)*1.525 er=er/eu*2 if er<1 then return el/2* (er*er* ((ec+1)*er-ec))+ed end er=er-2 return  el/2* (er*er* ((ec+1)*er+ec)+2)+ed end local function Q(er,ed,el,eu,ec)if er<eu/2 then return G(er*2,ed,el/2,eu,ec)end return B((er*2)-eu, ed+el/2,el/2,eu,ec)end local function J(er,ed,el,eu)er=er/eu if er<1/2.75 then return el* (7.5625*er*er)+ed end if er<2/2.75 then er=er- (1.5/2.75)return el* ( 7.5625*er*er+0.75)+ed elseif er<2.5/ 2.75 then er=er- (2.25/2.75)return el* (7.5625*er*er+0.9375)+ed end er=er- (2.625/2.75)return el* (7.5625*er*er+0.984375)+ed end local function X(er,ed,el,eu)return el-J(eu-er,0,el,eu)+ed end local function Z(er,ed,el,eu) if er<eu/2 then return X(er*2,0,el,eu)*0.5+ed end return J(er*2-eu,0,el,eu)*0.5+el*.5+ed end local function ee(er,ed,el,eu)if er<eu/2 then return J(er*2,ed,el/ 2,eu)end return X((er*2)-eu,ed+el/2,el/2,eu)end e.easing={linear=c,inQuad=m,outQuad=f,inOutQuad=w,outInQuad=y,inCubic=p,outCubic=v,inOutCubic=b,outInCubic=g,inQuart=k,outQuart=q,inOutQuart=j,outInQuart=x,inQuint=z,outQuint=_,inOutQuint=E,outInQuint=T,inSine=A,outSine=O,inOutSine=I,outInSine=N,inExpo=S,outExpo=H,inOutExpo=R,outInExpo=D,inCirc=L,outCirc=U,inOutCirc=C,outInCirc=M,inElastic=W,outElastic=Y,inOutElastic=P,outInElastic=V,inBack=B,outBack=G,inOutBack=K,outInBack=Q,inBounce=X,outBounce=J,inOutBounce=Z,outInBounce=ee} local function et(er,ed,el)el=el or ed local eu=getmetatable(ed)if eu and getmetatable(er)==nil then setmetatable(er,eu)end for ec,em in pairs(ed)do if i(em)=='table'then er[ec]=et({},em,el[ec])else er[ec]=el[ec]end end return er end local function ea(er,ed,el)el=el or{}local eu,ec for em,ef in pairs(ed)do eu,ec=i(ef),et({},el) table.insert(ec,o(em)) if eu=='number'then a(i(er[em])=='number',\"Parameter '\"..table.concat(ec,'/').. \"' is missing from subject or isn't a number\")elseif eu=='table'then ea(er[em],ef,ec)else a(eu=='number',\"Parameter '\"..table.concat(ec,'/').. \"' must be a number or table of numbers\")end end end local function eo(er,ed,el,eu) a(i(er)=='number'and er>0,\"duration must be a positive number. Was \"..o(er))local ec=i(ed) a(ec=='table'or ec=='userdata',\"subject must be a table or userdata. Was \"..o(ed)) a(i(el)=='table',\"target must be a table. Was \"..o(el)) a(i(eu)=='function',\"easing must be a function. Was \"..o(eu))ea(ed,el)end local function ei(er)er=er or\"linear\" if i(er)=='string'then local ed=er er=e.easing[ed]if i(er)~='function'then error(\"The easing function name '\"..ed..\"' is invalid\")end end return er end local function en(er,ed,el,eu,ec,em,ef)local ew,ey,ep,ev for eb,eg in pairs(ed)do if i(eg)=='table'then en(er[eb],eg,el[eb],eu,ec,em)else ew,ey,ep,ev=eu,el[eb], eg-el[eb],ec if ef then er[eb]=t.floor(em(ew,ey,ep,ev)+0.5)else er[eb]=em(ew,ey,ep,ev)end end end end local es={}local eh={__index=es} function es:set(er) a(i(er)=='number',\"clock must be a positive number or 0\")self.clock=er if self.clock<=0 then self.clock=0 et(self.subject,self.initial)elseif self.clock>=self.duration then self.clock=self.duration et(self.subject,self.target)else en(self.subject,self.target,self.initial,self.clock,self.duration,self.easing,self.round)end return self.clock>=self.duration end function es:reset()return self:set(0)end function es:update(er) a(i(er)=='number',\"dt must be a number\")return self:set(self.clock+er)end function e.new(er,ed,el,eu)eu=ei(eu)eo(er,ed,el,eu)return setmetatable({duration=er,subject=ed,target=el,easing=eu,initial=et({},el,ed),clock=0},eh)end return e"return o"main"